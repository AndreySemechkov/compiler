%{
	/* Project part 3 - Bison file */

	/**********************************************************************************
	 *                                   Includes
	 ***********************************************************************************/
#include <stdlib.h>
#include <stdio.h>
#include "common.h"
#include "definitions.h"
#include "parser.tab.hpp"
using namespace std;
	/**********************************************************************************
	 *                                   Header
	 ***********************************************************************************/

//Using yylval common data structure we transfer the data to the parser unit. 
	/**********************************************************************************
	 *                                   Function Declarations
	 ***********************************************************************************/
extern int yylex();
extern char* yytext;
extern int yylineno;
	
void yyerror(const char* msg);
	%}

/**********************************************************************************
 *                                   Tokens
 ***********************************************************************************/

%token TK_id
%token TK_real
%token TK_integer
%token TK_write
%token TK_read
%token TK_while
%token TK_do
%token TK_if
%token TK_then
%token TK_else
%token TK_main
%token TK_var
%token TK_call
%token TK_return
%token TK_defstruct
%token TK_extern
%token TK_num
%token TK_str
%token ':'
%token ';'
%token '{'
%token '}'
%token '('
%token ')'
%token ','
%token '['
%token ']'

/**********************************************************************************
 *                         Operators: Associativity 
 ***********************************************************************************/

%right TK_assign
%left TK_or
%left TK_and
%left TK_relop
%left TK_addop
%left TK_mulop
%right TK_not
%left '[' ']'
%left '{' '}'
%left '(' ')'
/**********************************************************************************
 *                         Operators: Precedence  
 ***********************************************************************************/

%precedence TK_then
%precedence TK_else

%%

/**********************************************************************************
 *                         Reduction rules - (and actions)
 *There are comments for the first few rules and all of the other are done the same way according 
 *to each reduction rule  
 ***********************************************************************************/

/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/
PROGRAM: TDEFS N FDEFS M MAIN_FUNCTION
{
    //making the halt line and adding the header to the buffer 
	vector<string> implementedLine;
	vector<string> unimplementedLine;
	vector<string> headerLines;
	
	
	
	if(isMain){
		//the current file that is parsed has the main
		headerLines.push_back("<main>");
		buffer.backpatch($2.nextList,$5.quad);//TODO check the backpatch
		buffer.emit("HALT");
	}
	else{
		// empty
		headerLines.push_back("<empty>");
		buffer.backpatch($2.nextList,0);//TODO check the backpatch
	}
	//add the <header> as the last line
		headerLines.push_back("<header>");
	
	unimplementedLine.push_back("<unimplemented>");
	implementedLine.push_back("<implemented>");
	bool firstFlag = true;
	for(map<string,Function>::iterator it = functionsTable.begin(); it != functionsTable.end(); ++it){
		if(it->second.implemented){
			//<implemented> foo,1 goo,2 doo
					implementedLine.push_back(" ");
					implementedLine.push_back(it->first);
					
					if(it->second.startLine > 0){
						implementedLine.push_back(",");
                                     		implementedLine.push_back(to_string(it->second.startLine));					                                       }
                                        else
					{
						cerr << "Semantic error: " << "no implementation for a non extern function" << endl;
						exit(EXIT_SEMANTIC_FAILURE);
					}
		}
		else{
			//<unimplemented> foo,1,2,23, goo,2,23,44, doo
			        if(!firstFlag){
			        	//the comma after the last linenum
			        	unimplementedLine.push_back(",");
			        }
			        firstFlag = false;
			        unimplementedLine.push_back(" ");
					unimplementedLine.push_back(it->first);
					vector<int>::iterator itVec = it->second.calledFromLines.begin();
					while( itVec != it->second.calledFromLines.end() ){
					    unimplementedLine.push_back(",");
						unimplementedLine.push_back(to_string(*itVec));
						++itVec;
					}
		}		
	}
	
	
	string unimplementedLineString;
	for(auto s : unimplementedLine){
			//<unimplemented> foo,1,2,23, goo,2,23,44, doo
			unimplementedLineString += s;
	}
	vector<string>:: iterator its = headerLines.begin();
	headerLines.insert(its,unimplementedLineString);
	
	string implementedLineString;
	for(auto s : implementedLine){
		//<implemented> foo,1 goo,2 doo to header lines
		implementedLineString += s;
	}
	vector<string>:: iterator itss = headerLines.begin();
	headerLines.insert(itss,implementedLineString);
	
	vector<string>:: iterator itsss = headerLines.begin();
	headerLines.insert(itsss,"</header>");
	
	for(auto line : headerLines){
	  buffer.insertHeader(line);
	}
}
;
/**********************************************************************************
 *                        TDEFS (struct declarations)
 ***********************************************************************************/

TDEFS: TDEFS TK_defstruct '{' DECLARLIST '}' TK_id ';'
{
	
	//the first struct will be parsed first
	
	//check that declarlist is OK. (no double declerations,etc)
	CmmStruct myStruct;
	for (auto& it : $4.dclNodes){
		
		try{
			myStruct.addField(it.second);
		}catch(string err){
			cerr << "Semantic error: " << err;
			cerr << " in line number " << it.first << endl;
			exit(EXIT_SEMANTIC_FAILURE);
		}
		
	}
	
	//verify that struct name is unique
	if(structsTable.find($6.value) != structsTable.end()){
		cerr << "Semantic error: " << "multiple definitions of struct name " + $6.value ;
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	
	//now, do the job!
	myStruct.m_name = $6.value;
	structsTable.insert(std::make_pair($6.value, myStruct));
	
}
| /*epsilon*/{}
;

/**********************************************************************************
 *                        FDEFS
 ***********************************************************************************/

FDEFS: FDEFS TYPE TK_id '(' FUNC_ARGLIST_FULL ')'

{
	// A big midrule action , in order to add the function to 
	//the function table before BLK will be called
	
	Function f;
	f.returnType = $2.type;	
	f.name = $3.value;
	f.implemented = true;
	f.startLine = buffer.nextQuad();
	//TODO: startLine? offset?

	//assert that the the type is INT or REAL
	if(f.returnType != INT && f.returnType != REAL){
		//semantic error
		cerr << "Semantic error: Function return type must be INT or REAL.";
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
		
	}
	
	//check DCL nodes:
	//for uniqueness.
	
	int i = 0;
	for( auto& it : $5.dclNodes){
		
		FunctionSymbol sym;
		sym.name = it.second.name;
		sym.type = it.second.type;
		sym.offset = -i + INITIAL_OFFSET;
		++i;
		try{
			f.addSymbol(sym);
		}catch(string err){
			
			cerr << "Semantic error: " << err ;
			cerr << " in line number " << it.first << endl;
			exit(EXIT_SEMANTIC_FAILURE);
			
		}
		
	}
	
	if(functionsTable.find(f.name) != functionsTable.end()){
		cerr << "Semantic error: Multiple declarations of function `" + f.name + "`";
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}else{
		
		functionsTable.insert(std::make_pair(f.name , f ));
	}
	
	//forget temporrary registers! reset register bank!
	bank = RegistersBank();
	
	
	//TODO:
	//push a new symbol table to the sybol tables stack
	//add all the function parmeters to the symbol table.
	//get function symbol table
		
		TableOfSymbols functionSymbolTable;
		functionSymbolTable.tmpFunctionNewScopeStart();
		for (auto& symb : f.m_symbols_list){
			
			try{
				
				//addr = sp now,
				functionSymbolTable.addSymbol(symb.name ,symb.type, symb.offset );
						//then push it to mem.
			
			}catch(string s){
				/// our internal errorr!!
				assert(0);
				
			}
			
			
		}
		functionSymbolTable.tmpFunctionNewScopeEnd();
	
} BLK {
	
	//DO ANYTHING? //fixme
		
}
| FDEFS TK_extern TYPE TK_id '(' FUNC_ARGLIST_FULL ')' ';' {
	// A big midrule action , in order to add the function to 
	//the function table before BLK will be called
	
	Function f;
	f.returnType = $2.type;	
	f.name = $3.value;
	f.implemented = false;
	f.startLine = UNDEFINED_START_LINE;
	//TODO: startLine? offset?

	//assert that the the type is INT or REAL
	if(f.returnType != INT && f.returnType != REAL){
		//semantic error
		cerr << "Semantic error: Function return type must be INT or REAL.";
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
		
	}
	
	//check DCL nodes:
	//for uniqueness.
	
	int i = 0;
	for( auto& it : $5.dclNodes){
		
		FunctionSymbol sym;
		sym.name = it.second.name;
		sym.type = it.second.type;
		sym.offset = i + INITIAL_OFFSET;
		++i;
		
		try{
			f.addSymbol(sym);
		}catch(string err){
			
			cerr << "Semantic error: " << err ;
			cerr << " in line number " << it.first << endl;
			exit(EXIT_SEMANTIC_FAILURE);
			
		}
		
	}
	
	if(functionsTable.find(f.name) != functionsTable.end()){
		cerr << "Semantic error: Multiple declarations of function `" + f.name + "`";
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}else{
		
		functionsTable.insert(std::make_pair(f.name , f ));
	}
	
}
| /*epsilon*/{
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

FUNC_ARGLIST_FULL: FUNC_ARGLIST {
	
	$$.dclNodes= $1.dclNodes;
	
}
| /*epsilon*/{
	$$.dclNodes = std::list<std::pair<string,DCLnode> > (); // empty list...
	
	//no params
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

FUNC_ARGLIST: FUNC_ARGLIST ',' DCL {

	//check types
	if($3.type != REAL && $3.type != INT){
		
		cerr << "Semantic error: Function arguments be INT or REAL.";
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	
	//concatinate
	$1.dclNodes.splice($1.dclNodes.end(), $3.dclNodes );
	$$.dclNodes = $1.dclNodes;
	
	
}
| DCL {
	
	//check types:
	if($1.type != REAL && $1.type != INT){
		
		cerr << "Semantic error: Function arguments be INT or REAL.";
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
		
	}
	//add to list
	$$.dclNodes = $1.dclNodes ;
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

MAIN_FUNCTION: TK_main {
	
	//mid rull atcion:
	
	//init SP and FP
	//buffer.emit("COPYI I0 0");
	buffer.emit("COPYI I1 0"); //INT FP
	buffer.emit("COPYI I2 0"); //INT SP
	buffer.emit("COPYI I3 0"); //REAL FP
	buffer.emit("COPYI I4 0"); //REAL SP

	currentFunctionReturnType.push(NONE);
	symbolTable.push(TableOfSymbols());
} BLK {
	currentFunctionReturnType.pop();
	symbolTable.pop();
	isMain = true; //THE FILES CONTAIOS MAIN FUNCTION!

	// each function has its local scope with a clean table of its scope and its inner symbols.
	//TableOfSymbols localTableOfSymbols;
}
| /*epsilon*/{
	isMain = false;
	
}
;

BLK: DECLARATIONS '{' LIST '}' {
	// each function has its local scope with a clean table of its scope and its inner symbols.
	//TableOfSymbols localTableOfSymbols;

	//we reached the end the scope, update symbolTable.top()
	int real_sum;
	int int_sum;
	symbolTable.top().endScope(&real_sum, &int_sum);
	
	buffer.emit("SUBTI I2 I2 " + to_string(int_sum));
	buffer.emit("SUBTI I4 I4 " + to_string(real_sum));
	
	mem.endBLK();
	
	//reset register bank - (temporary registers)
	bank = RegistersBank();
}
;
/**********************************************************************************
 *                        DECLARATIONS
 ***********************************************************************************/

DECLARATIONS: TK_var DECLARLIST {
	mem.startBLK();
	
	//get num int fields, get num real fields, + add to sp
	
	int real_sum =0 ;
	int int_sum = 0;
	for(auto& it : $$.dclNodes){
		real_sum+= it.second.getNumRealFields();
		int_sum+= it.second.getNumIntFields();
	}
	
	//add to sp
	buffer.emit("ADD2I I2 I2 " + to_string(int_sum));
	buffer.emit("ADD2I I4 I4 " + to_string(real_sum));
	
	symbolTable.top().startNewScope(real_sum,int_sum);

	//for every symbol, calc its addr = lastUsedAddr,
	//update lastUsedAddr += symbol->NumFields
	//numFeilds = type == INT or REAL ? 1 : structTable-->getnumFields

	for(auto& it : $2.dclNodes) {

		//calculate address:
				
		//simple types first:

		if(! it.second.isStruct()) {
			//if type = real
			//if type = int
			int myAdder=mem.getMem(it.second.type);
			
			//now, add to table:
			try {
				symbolTable.top().addSymbol(it.second.name , it.second.type , myAdder);
			} catch(string e) {
				cerr << "Semantic error: symbol '" << e << "' multiple defnitions";
				cerr << " in line number " << it.first << endl;
				exit(EXIT_SEMANTIC_FAILURE);
			}
			
			
		}else{

			//if type = struct...
			//TODO:
			
			//stage1: lookup in structsTable, and check if it exists
			
			std::map<std::string,CmmStruct>::iterator structITR = structsTable.find(it.second.name);
			//if it does not exists: semantic error
			if(structITR== structsTable.end()){
				cerr << "Semantic error: '" << it.second.name << "' does not name a type";
				cerr << " in line number " << it.first << endl;
				exit(EXIT_SEMANTIC_FAILURE);
				
			}
			//stage2: get addr from memHandler
			//getBulkMemory for it!
			int myINTAddr = mem.getBulkMem(INT,it.second.getNumIntFields());
			int myREALAddr = mem.getBulkMem(REAL,it.second.getNumRealFields());
			
			//stage3: try to add to table
			try {

			symbolTable.top().addSymbolStruct(it.second.name , it.second.type, myINTAddr, myREALAddr );
			} catch(string e) {
				cerr << "Semantic error: symbol '" << e << "' multiple defnitions";
				cerr << " in line number " << it.first << endl;
				exit(EXIT_SEMANTIC_FAILURE);
			}
		}

	}

	//try to add all the parsed symbols to the main symbol table.
	//catch anything : semnatic error.

}
| /*epsilon*/{
	symbolTable.top().startNewScope(0,0);  // only because we call end scope in BLK
}
;
/**********************************************************************************
 *                        DECLARLIST //fixme
 ***********************************************************************************/

DECLARLIST: DECLARLIST DCL ';' {

	//if DCL is more then one declaration, 
	//split it into serveral nodes

	//splice all the lists to DECLARLIST list:
	$1.dclNodes.splice($1.dclNodes.end(), $2.dclNodes );
	$$.dclNodes = $1.dclNodes;
}

| DCL ';' {
//first declaration.
	//splice the DCL list into DECLARLIST list
	$$.dclNodes = $1.dclNodes ;
	//if it its more then one declaration, 
	//split it into serveral nodes
	
}
;
/**********************************************************************************
 *                        DCL //fixme
 ***********************************************************************************/

DCL: TK_id ':' TYPE {
//decleration of a REAL or INT
	//stage1: create a dcl node:
	DCLnode dcl;
	dcl.name = $1.value;
	dcl.type = $3.type;
	dcl.structDescriptor = NULL;
	//stage2: push to list
	$$.dclNodes.push_back(std::make_pair(to_string(yylineno),dcl));
}
| TK_id ':' TK_id {
//decleration of struct
	
	// fist check that the stuct exists in the structs table
	std::map<std::string,CmmStruct>::iterator it =  structsTable.find($3.value);
	
	//not found
	if(it==structsTable.end() ){
		//semantic error
		cerr << "Semantic error: '" << $3.value << "' does not name a type";
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	
	//stage1: create a dcl node:
		DCLnode dcl;
		dcl.name = $1.value;
		dcl.type = $3.type;
		dcl.structDescriptor = (&(it->second));
	//stage2: push to list
		$$.dclNodes.push_back(std::make_pair(to_string(yylineno),dcl));

}
| TK_id ',' DCL {
//more then one declaration in the same line

	//create a node for the new Id (left)
	DCLnode dcl;
	dcl.name = $1.value;
	dcl.type = $3.dclNodes.begin()->second.type;
	dcl.structDescriptor = $3.dclNodes.begin()->second.structDescriptor;

	//now, splice all the lists (new node + previeous nodes) to $$ list.
	$$.dclNodes.push_back(std::make_pair(to_string(yylineno),dcl));
	$$.dclNodes.splice($$.dclNodes.end(), $3.dclNodes);
		
}
;
/**********************************************************************************
 *                        TYPE
 ***********************************************************************************/

TYPE: TK_integer {

	$$.type = INT;
}
| TK_real {
	$$.type = REAL;
}
;
/**********************************************************************************
 *                        LIST
 ***********************************************************************************/
//added a marker
LIST: LIST M STMT {
	/*using backpatch in order to concatenate
	 all the statesments of the main program.*/
	$$.nextList = $3.nextList;
	$3.nextList.clear(); //will be taken care by backpatching the LIST in the next derevation
	buffer.backpatch($1.nextList, $2.quad);
}
| /*epsilon*/{}
;
/**********************************************************************************
 *                        STMT
 ***********************************************************************************/

STMT: ASSN {}
| CNTRL {
	$$.nextList = $1.nextList; //in order to backpatch
}
| READ {}
| WRITE {}
| STMT_RETURN {}
| BLK {}
;
/**********************************************************************************
 *                        STMT_RETURN //TODO
 ***********************************************************************************/

STMT_RETURN: TK_return '(' EXP ')' ';' {
	
	if(currentFunctionReturnType.empty() || currentFunctionReturnType.top() == NONE){
		cerr << "Semantic error: return statement inside main()";
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	
	if($3.type!=currentFunctionReturnType.top()){
		cerr << "Semantic error: return type does not match expected type ";
		cerr << "in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	
	string eStore = ($3.type == INT)? "STORI I" : "STORR R";
	$$.registerNum = bank.getRegister($3.type);
	string fp = $3.type == INT ? "I1" : "I3"; 
	buffer.emit(eStore + to_string($$.registerNum) + " " + fp + " -1"); //I1 -- fram PTR
	buffer.emit("RETRN"); //goto IO
	//clear tmp registers:
	bank = RegistersBank();
}
;
/**********************************************************************************
 *                        WRITE
 ***********************************************************************************/

WRITE: TK_write '(' EXP ')' ';' {

	if ($3.type == INT) {
		buffer.emit("PRNTI I" + to_string($3.registerNum));
	}
	else if ($3.type == REAL) {
		buffer.emit("PRNTR R" + to_string($3.registerNum));
	} else {
		//(our internal error)
	}

}
| TK_write '(' TK_str ')' ';' {

	for (size_t i = 0; i < $3.value.length(); i++) {
		char currentChar = $3.value[i];
		//take care of \n and \r :
		if (currentChar == '\\' && $3.value[i+1] == 'n') {
			currentChar = '\n';
			i++;
		} else if (currentChar == '\\' && $3.value[i+1] == 't') {
			currentChar = '\t';
			i++;
		}
		//cast to asci
		int asci_char = static_cast<int>(currentChar);
		buffer.emit("PRNTC " + to_string(asci_char));
	}

}
;
/**********************************************************************************
 *                        READ
 ***********************************************************************************/

READ: TK_read '(' LVAL ')' ';' {

	//check for type semantics
	if($3.type != INT && $3.type != REAL) {
		//semantic error - read exept only INT or REAL
		cerr << "Semantic error:"
		<< " READ expecting types: REAL or INT "
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}

	//stage1 read into a temp register
	//compute string to emit
	string toEmitRead = ($3.type == INT) ? "READI I" : "READR R";
	int reg = bank.getRegister($3.type);// the register we read into
	toEmitRead+= to_string(reg);
	//now, do the job
	buffer.emit(toEmitRead);

	//stage2: store to mem
	//compute string to emit
	string toEmitStore = ($3.type == INT) ? "STORI I" : "STORR R";
	toEmitStore+= to_string(reg);
	string fp = $3.type == INT ? "I1" : "I3"; 
	toEmitStore = toEmitStore + " " + to_string($3.addr) + " "+fp;//the LVAL is in memmorry, addr stores where //FIXME:

	//now, do the job
	buffer.emit(toEmitStore);
}
;
/**********************************************************************************
 *                        ASSN
 ***********************************************************************************/

ASSN: LVAL TK_assign EXP ';' {

	//SEMANTIC CHECKS: assert both have the same types
	if($1.type != $3.type) {
		cerr << "Semantic error:"
		<< " ASSN expecting same types "
		<< " in line number " << to_string(yylineno) << endl;
	}

	//set type
	$$.type = $1.type;

	//case 1 : type is REAL or INT
	if($$.type == REAL || $$.type == INT) {

		// assign value to lval memory.

		string toEmitStore = ($$.type == INT ) ? "STORI I" : "STORR R";
		string fp = $$.type == INT ? "I1" : "I3"; 
		buffer.emit(toEmitStore + to_string($3.registerNum) + " " + to_string($1.addr) + " "+fp); //offset+FP
	}else{	//TODO:


	//case 2: assignment between structs 
		
		//2.1 : verify that they are struct from the same type:
		CmmStruct* sdLeft = $1.oldFieldD->structDescriptor;
		CmmStruct* sdRight = $3.oldFieldD->structDescriptor;
		
		//TODO: maybe assert they are not NULL? although this should not happen.
		
		if(sdLeft->m_name != sdRight->m_name){			
			cerr << "Semantic error:"
			<< " ASSN expecting same types "
			<< " in line number " << to_string(yylineno) << endl;
		}
		
		//now, do the job
		int left_int_start_addr = $1.INTaddr;
		int left_real_start_addr = $1.REALaddr;
		int right_int_start_addr = $3.INTaddr;
		int right_real_start_addr = $3.REALaddr;
		
		assignStructs(sdLeft->m_fields_list, 
				left_int_start_addr, 
				left_real_start_addr, 
				right_int_start_addr, right_real_start_addr);
		
	}
}
;
/**********************************************************************************
 *                        LVAL
 ***********************************************************************************/

LVAL: TK_id {
	//(if type is INT or REAL, then READ will work) else, its a struct..
	//SEMANTIC CHECKS:
	//is id in the sybol table?
	string name = $1.value;
	bool exists = symbolTable.top().find(name);
	if(!exists) {
		cerr << "Semantic error: undeclared symbol '" << name << "' ";
		cerr << "in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	//lval can be a struct!

	//init LVL:
	$$.value = name;
	try
	{
		// set type of EXP :
		$$.type = symbolTable.top().getType(name);

		if($$.type != REAL && $$.type != INT) {
			//todo:
			//means it is a struct, do we have to do something special?
			//no! it fine we already did a lookup, and we can do it again if needed..
		}else{
			//INT,REAL case
			$$.addr = symbolTable.top().getAddr(name);
		}
	} catch(string e)
	{
		cerr << "Semantic error: undeclared symbol '" << e << "' ";
		cerr << "in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}

	//anything else?	
}
| STREF {
	//copy all
	$$ = $1;
	
	if($1.type == INT || $1.type == REAL){
		//simple type, 
		//so same as above, but with different addr calculation:
		$$.addr = ($1.type == INT) ? $1.INTaddr : $1.REALaddr;		
		
	}else{
		//struct!
		//do we have all we need baby?
		//FIXME:
	}
	
	//todo: set type as something different from INT and REAL (for READ to work) ???
}
;
/**********************************************************************************
 *                        CNTRL
 ***********************************************************************************/

CNTRL: TK_if BEXP TK_then M STMT TK_else N M STMT {
	/* $1 if
	 * $2 B
	 * $3 then
	 * $4 M1
	 * $5 S1
	 * $6 else
	 * $7 N
	 * $8 M2
	 * $9 S2
	 */
	buffer.backpatch($2.trueList, $4.quad);
	buffer.backpatch($2.falseList, $8.quad);
	// merge all three to S list
	set<int> tmp;
	MERGE(tmp, $5.nextList, $7.nextList);
	MERGE($$.nextList, tmp, $9.nextList);
}
| TK_if BEXP TK_then M STMT {
	/* $1 if
	 * $2 B
	 * $3 then
	 * $4 M
	 * $5 S
	 */
	buffer.backpatch($2.trueList , $4.quad);
	MERGE($$.nextList, $2.falseList, $5.nextList);
}
| TK_while M BEXP TK_do M STMT {
	/* $1 while
	 * $2 M1
	 * $3 B
	 * $4 do
	 * $5 M2
	 * $6 S1
	 */
	buffer.backpatch($6.nextList , $2.quad);
	buffer.backpatch($3.trueList , $5.quad);
	$$.nextList = $3.falseList;
	buffer.emit("UJUMP " + to_string($2.quad));
}
;
/**********************************************************************************
 *                        BEXP
 ***********************************************************************************/

BEXP: BEXP TK_or M BEXP {
	buffer.backpatch($1.falseList , $3.quad);
	MERGE($$.trueList, $1.trueList , $4.trueList);
	$$.falseList = $4.falseList;
}
| BEXP TK_and M BEXP {

	buffer.backpatch($1.trueList , $3.quad);
	$$.trueList = $4.trueList;
	MERGE($$.falseList, $1.falseList , $4.falseList);

}
| TK_not BEXP {
	$$.trueList = $2.falseList;
	$$.falseList = $2.trueList;
}
| EXP TK_relop EXP {
	//semantics checks
	//same type
	if($1.type != $3.type) {
		//semantic error
		cerr << "Semantic error:"
		<< " EXP TK_relop EXP - types must be the same"
		<< " in line number " << to_string(yylineno) << endl;
	}
	//real of int only
	if($1.type != REAL && $1.type != INT) {
		//semantic error
		cerr << "Semantic error:"
		<< " EXP TK_relop EXP expecting types: REAL or INT "
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}

	//allocate INT register for comparsion result
	$$.registerNum = bank.getRegister(INT);

	//the logic here is simple:
	//if ! (left relop right) branch <--------------- falseList
	//goto...                        <--------------- trueList

	//decide how to compare and branch
	string toEmitCompare;
	string toEmitBranch;

	if ($2.value == "==") {
		toEmitCompare = "SEQU";
		toEmitBranch = "BREQZ";

	} else if ($2.value == "<>") {
		toEmitCompare = "SNEQ";
		toEmitBranch = "BREQZ";

	} else if ($2.value == "<") {
		toEmitCompare = "SLET";
		toEmitBranch = "BREQZ";

	} else if ($2.value == ">=") {
		toEmitCompare = "SLET";
		toEmitBranch = "BNEQZ";

	} else if ($2.value == ">") {
		toEmitCompare = "SGRT";
		toEmitBranch = "BREQZ";

	} else if ($2.value == "<=") {
		toEmitCompare = "SGRT";
		toEmitBranch = "BNEQZ";
	}

	//add type letter to toEmitCompare string
	string type_str = ($1.type == INT) ? "I" : "R";
	toEmitCompare+=type_str;

	//add the rest to compare_str
	toEmitCompare+=" I" + to_string($$.registerNum) + " " + type_str + to_string($1.registerNum) + " " + type_str + to_string($3.registerNum);

	//add the rest to branch_str , leave space to be later backpatched...
	toEmitBranch+=" I" + to_string($$.registerNum) + " ";

	//now, do the job!
	buffer.emit(toEmitCompare);
	$$.falseList.insert(buffer.nextQuad());// falselist - branch
	buffer.emit(toEmitBranch);
	$$.trueList.insert(buffer.nextQuad());//true list - goto
	buffer.emit("UJUMP ");
}
| '(' BEXP ')' {
	$$.trueList = $2.trueList;
	$$.falseList = $2.falseList;
}
;
/**********************************************************************************
 *                        EXP
 ***********************************************************************************/

EXP: EXP TK_addop EXP {

	int leftRegister = $1.registerNum;
	int rightRegister = $3.registerNum;

	//check types
	if($1.type != $3.type) { //different types
		//erorr
		cerr << "Semantic error:"
		<< " different types, EXP  TK_addop EXP"
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	//set my type
	if($1.type == REAL) {
		$$.type = REAL;
	} else if($1.type = INT) {
		$$.type = INT;
	} else {
		//semantic error
		cerr << "Semantic error:"
		<< " EXP TK_addop EXP expecting types: REAL or INT "
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}

	//EMIT
	string myType;
	if ($$.type == REAL) {
		myType += "R";
	}
	else {
		myType += "I";
	}

	$$.registerNum = bank.getRegister($$.type);

	if ($2.value == "+") {
		buffer.emit("ADD2" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
	}
	else { // "-"
		buffer.emit("SUBT" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
	}
}
| EXP TK_mulop EXP {

	int leftRegister = $1.registerNum;
	int rightRegister = $3.registerNum;

	//check types
	if($1.type != $3.type) { //different types
		//erorr
		cerr << "Semantic error:"
		<< " different types, EXP*EXP"
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	//set my type
	if($1.type == REAL) {
		$$.type = REAL;
	} else if($1.type = INT) {
		$$.type = INT;
	} else {
		//semantic error
		cerr << "Semantic error:"
		<< " EXP TK_mulop EXP expecting types: REAL or INT "
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);

	}
	//EMIT

	string myType;
	if ($$.type == REAL) {
		myType += "R";
	}
	else {
		myType += "I";
	}

	$$.registerNum = bank.getRegister($$.type);

	if ($2.value == "*") {
		buffer.emit("MULT" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
	}
	else { // "/"
		buffer.emit("DIVD" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
	}

}
| '(' EXP ')' {

	$$ = $2;
}
| '(' TYPE ')' EXP {
	// Explicit casting: int to real and real to int. (or casting from the same type. all other casting options are semantics errors.

	if( ($2.type != INT && $2.type != REAL) || ($4.type != INT && $4.type != REAL)) {

		//semantic error
		cerr << "Semantic error:"
		<< " '(' TYPE ')' EXP types should be INT or REAL"
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);

	}
	if($2.type == REAL) {
		$$.type = $2.type; //REAL

		if ($4.type == INT) {
			// TYPE the actual type is a string in .type field

			//get register
			$$.registerNum = bank.getRegister($$.type);

			//emit
			buffer.emit("CITOR R" + to_string($$.registerNum) + " I" + to_string($4.registerNum));

		} else { // both types are ints
			//nothing to do do ...

		}

	} else if($2.type == INT) {
		$$.type = $2.type;			//INT

		if ($4.type == REAL) {
			// TYPE the actual type is a string in .type field

			//get register
			$$.registerNum = bank.getRegister($$.type);

			// emit
			buffer.emit("CRTOI I" + to_string($$.registerNum) + " R" + to_string($4.registerNum));

		} else { // both types are real
			//nothing to do do ...
		}

	} else { // already taken care of.. but nvm
		//semantic error
		cerr << "Semantic error:"
		<< " '(' TYPE ')' EXP types should be INT or REAL"
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
}
| TK_id {

	// check if id is declared in the current scope:
	string name = $1.value;
	$$.value = $1.value;

	//semantics checks:
	bool exists = symbolTable.top().find(name);
	if (!exists) {
		cerr << "Semantic error: undeclared symbol '" << name << "' ";
		cerr << "in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}

	// check if id is int or real:
	t_type myType = symbolTable.top().getType(name);
	
	// set type of EXP :
	$$.type = myType;

	
	if ( myType != INT && myType!= REAL) {
//		cerr << "Semantic error: invalid use of symbol '" << name << "'";
//		cerr << "in line number " << to_string(yylineno) << endl;
//		exit(EXIT_SEMANTIC_FAILURE);
		
		//then it is a struct!
		//TODO
		//will be used only in assignment.
		//in assignment - we do:
		//looup name=$$.value in symbol table. 
		//calculate offset how many fields of each type we have
		//calculate start offsets for each.
		//copy mem! (load to reg, store from reg to mem...)
		
		
		//(we will use the $$.value in order to lookop it in the structs table)
		
		
	}else{ //INT or REAL
	//FIXME:
		
		//init EXP:	
		string toEmitLoad = ($$.type == INT) ? "LOADI I" : "LOADR R";
	
		// allocate a register for EXP :
		$$.registerNum = bank.getRegister($$.type);
		toEmitLoad+= to_string($$.registerNum);
	
		//get adder, in order to load
		int addr = symbolTable.top().getAddr(name);
		//TODO: should save the addr for EXP ? (I think we should not, so I avoid saving it to avoid errors).
		//$$.addr = addr;
		//load to register
		string fp = $$.type == INT ? "I1" : "I3"; 

		buffer.emit(toEmitLoad + " "+fp+" " + to_string(addr));//FIXME: check if the address is right
	}
}
| STREF {
	
	//internal struct field.
	//TODO:
	$$.type = $1.type;

	//case 1: int or real - load to reg
	if($1.type == INT || $1.type == REAL){
		
		if($1.type == INT){
			$$.addr =  $1.INTaddr;
		}else if($1.type == REAL){
			$$.addr =  $1.REALaddr;
		}
		
		$$.registerNum = bank.getRegister($$.type);
		string toEmitLoad = ($$.type == INT) ? "LOADI I" : "LOADR R";
		toEmitLoad+= to_string($$.registerNum);
		
		string fp = $$.type == INT ? "I1" : "I3"; 

		buffer.emit(toEmitLoad + " " +fp+ " " + to_string($$.addr));//FIXME: check if the address is right
	}else{
		//struct!
		//take care only in assinment, keep all data (just in case..)
		$$ = $1;
	}	
}
| TK_num {
	//deterine value
	if ($1.value.find('.') != $1.value.npos) {
		$$.type = REAL;
	}
	else {
		$$.type = INT;
	}
	//ger register
	$$.registerNum = bank.getRegister($$.type);

	//emit
	if ($$.type == REAL) { //real
		buffer.emit("COPYR R" + to_string($$.registerNum) + " " + $1.value);
	}
	else { //int
		buffer.emit("COPYI I" + to_string($$.registerNum) + " " + $1.value);
	}

}
| CALL {
	
	$$.registerNum = $1.registerNum;
	$$.type = $1.type;
}
;
/**********************************************************************************
 *                        STREF //TODO:
 ***********************************************************************************/

STREF: TK_id '[' TK_id ']' {
	
	//lookup id in symbol table	//id is the "father"
	//verify it exists
	if(! symbolTable.top().find($1.value)){
		cerr << "Semantic error: undeclared symbol '" << $1.value << "' ";
		cerr << "in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
		
	}
	//verify its a struct (and not just an INT or REAL)
	if(! symbolTable.top().isStruct($1.value)){
		cerr << "Semantic error: can't STREF. symbol '" << $1.value << "' is not a struct!";
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	//get its typename, 
	string typeName = symbolTable.top().getTypeName($1.value);
	//verify it is a declared struct! 
	//lookup in structs table
	std::map<std::string,CmmStruct>::iterator father = structsTable.find(typeName);
	
	//if it does not exists- semantic error!
	if(father==structsTable.end()){
		cerr << "Semantic error: can't STREF. symbol '" << $1.value << "' is not a decleraed struct!";
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
		
	}
	
	//get fathers start adress, and denote it as MS (my start address)
	 
	int startAddr_INT = symbolTable.top().getINTStartAddr($1.value);
	int startAddr_REAL = symbolTable.top().getREALStartAddr($1.value);

		
	//see if it has a field named id
	//if not, semantic error
	
	CmmStructField * fieldD;
	
	try{
		fieldD = father->second.getFieldByName($1.value);
	}catch(string err){
		cerr << "Semantic error: " << err;
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	

	//TODO:
	
	//get init offset inside struct 
	$$.INToffsetInsideStruct = fieldD->INToffsetInsideStruct;
	$$.REALoffsetInsideStruct = fieldD->REALoffsetInsideStruct;

	
	//addr = MO+MS
	
	$$.INTaddr   =  $$.INToffsetInsideStruct + startAddr_INT ;
	$$.REALaddr  =  $$.REALoffsetInsideStruct + startAddr_REAL ;

	$$.type = fieldD->type;
	$$.oldFieldD = fieldD;

}
| STREF '[' TK_id ']' {
	
	//semantic checks
	
	//if it is a simple type: semantic error
	if($1.type == INT || $1.type == REAL ){ 
		
		string t = ($1.type == INT) ? "INT" : "REAL" ;
		
		cerr << "Semantic error: can't STREF. type '" << t << "'. it is not a struct!";
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
		
	}
	
	//check wheter STREF has a field name id
	//if true, get it
	CmmStructField * fieldD;
	try{
		fieldD = $$.oldFieldD->structDescriptor->getFieldByName($3.value);
	}catch(string err){ //else, semantic error
		cerr << "Semantic error: STREF " << err;
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	
		
		//compute total offset inside struct 
		$$.INToffsetInsideStruct += fieldD->INToffsetInsideStruct;
		$$.REALoffsetInsideStruct += fieldD->REALoffsetInsideStruct;

		
		//addr = MO+MS
		
		$$.INTaddr   += fieldD->INToffsetInsideStruct;
		$$.REALaddr  += fieldD->REALoffsetInsideStruct ;

		$$.type = fieldD->type;
		$$.oldFieldD = fieldD;

}
;
/**********************************************************************************
 *                        CALL //TODO
 ***********************************************************************************/

CALL: TK_call TK_id '(' CALL_ARGS_FULL ')' {


	std::map<std::string, Function>::iterator fI = functionsTable.find($2.value);
	//check that ID exists
	if(fI == functionsTable.end() ){
		cerr << "Semantic error: no matching call for function " << $2.value;
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	
	//check if args types match?
	
	std::list<t_type> tmp;
	

	for (auto& it : $4.paramNodes){
		tmp.push_back(it.first);
	}
	
	if( fI->second.m_types !=  tmp ){
		cerr << "Semantic error: parameteres of function call does not match function " << $2.value ;
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
		
	}
	
	
	//if we got here, then args match!
	
	
	//now, do the job:
	
	//take care of stack, etc
	
	
	
	//insert arguments in revers!
	int intCount=0;
	int realCount=0;
	for (auto i = $4.paramNodes.rbegin(); i != $4.paramNodes.rend(); ++i) {
		
		if(i->first == INT){
			buffer.emit("STORI I" + to_string(i->second) + " I2 " + to_string(intCount++));

		}else if(i->first == REAL){
			buffer.emit("STORR R" + to_string(i->second) + " I4 " + to_string(realCount++));
		}else{
			assert(0); //our internal error
		}
	}
	
	
	//then update sp + insert an empty place for results (the +1)
	buffer.emit("ADD2I I2 I2 " + to_string(intCount+1));
	buffer.emit("ADD2I I4 I4 " + to_string(realCount+1));
		
	
	
	//tmp register to remember old FP (function call from inside block)
	buffer.emit("COPYI I5 I1");
	buffer.emit("COPYI I6 I2");
	
	//then set fp=fp (for both types)
	buffer.emit("COPYI I1 I2");
	buffer.emit("COPYI I3 I4");

	
	//emit the call (to startLine)
	buffer.emit("JLINK " + to_string(fI->second.startLine));
	
	
	//get the return value and type
	$$.type = fI->second.returnType;
	$$.registerNum = bank.getRegister($$.type );
	string resultLoad = ($$.type == INT) ? "LOADI I" : "LOADR R";
	string sp = $$.type == INT ? "I2" : "I4"; 

	buffer.emit(resultLoad + to_string($$.registerNum) + " " +sp+ "-1"); //sp -1
	
	
	//restore fp
	buffer.emit("COPYI I1 I5");
	buffer.emit("COPYI I2 I6");
	
	//restore sp
	
	buffer.emit("SUBTI I2 I2 " + to_string(intCount+1));
	buffer.emit("SUBTI I4 I4 " + to_string(realCount+1));
	
}
;

CALL_ARGS_FULL: CALL_ARGS {
	$$.paramNodes == $1.paramNodes;
}
| /*epsilon*/{
	
	$$.paramNodes.clear();
}
;

CALL_ARGS: EXP {
	//first param node
	
	//check if EXP is INT or REAL
	
	if($1.type != INT && $1.type != REAL){
		cerr << "Semantic error: function call parameters must be INT or REAL only! ";
		cerr << " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	
	$$.paramNodes.clear();
	$$.paramNodes.push_back(std::make_pair($1.type,$1.registerNum));	
	
}
| CALL_ARGS ',' EXP {
	
	//check if EXP is INT or REAL
		
		if($3.type != INT && $3.type != REAL){
			cerr << "Semantic error: function call parameters must be INT or REAL only! ";
			cerr << " in line number " << to_string(yylineno) << endl;
			exit(EXIT_SEMANTIC_FAILURE);
		}
	
	$$.paramNodes = $1.paramNodes;
	$$.paramNodes.push_back(std::make_pair($3.type,$3.registerNum));	
	
}
;
/**********************************************************************************
 *                        MARKERS :
 ***********************************************************************************/

M : /* epsilon */
{
	$$.quad = buffer.nextQuad();
}

N : /* epsilon */
{
	// set the nextList
	$$.nextList.insert(buffer.nextQuad());

	// emit goto
	buffer.emit("UJUMP ");
}

%%

// printig an error when no reduction rule can be applied.code 2 of error as requested showind the syntax error details
void yyerror(const char* msg){
	printf("Syntax error: '%s' in line number %d\n", yytext, yylineno);
	exit(EXIT_SYNTAX_FAILURE);
}

