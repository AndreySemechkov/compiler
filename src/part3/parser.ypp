% {
	/* Project part 3 - Bison file */

	/**********************************************************************************
	 *                                   Includes
	 ***********************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include "common.hpp"
#include "parser.tab.hpp"
	using namespace std;
	/**********************************************************************************
	 *                                   Header
	 ***********************************************************************************/
//We create the parser nodes for each token in the lexical analyser. 
//Using yylval common data structure we transfer the nodes to the parser unit. 
//In the parser we only create the father node, connect the nodes and build the tree.
	/**********************************************************************************
	 *                                   Function Declarations
	 ***********************************************************************************/
	extern int yylex();
	extern char* yytext;
	extern int yylineno;
	void yyerror(const char* msg);
	%}

/**********************************************************************************
 *                                   Tokens
 ***********************************************************************************/

%token TK_id
%token TK_real
%token TK_integer
%token TK_write
%token TK_read
%token TK_while
%token TK_do
%token TK_if
%token TK_then
%token TK_else
%token TK_main
%token TK_var
%token TK_call
%token TK_return
%token TK_defstruct
%token TK_extern
%token TK_num
%token TK_str
%token ':'
%token ';'
%token '{'
%token '}'
%token '('
%token ')'
%token ','
%token '['
%token ']'

/**********************************************************************************
 *                         Operators: Associativity 
 ***********************************************************************************/

%right TK_assign
%left TK_or
%left TK_and
%left TK_relop
%left TK_addop
%left TK_mulop
%right TK_not
%left '[' ']'
%left '{' '}'
%left '(' ')'
/**********************************************************************************
 *                         Operators: Precedence  
 ***********************************************************************************/

%precedence TK_then
%precedence TK_else

%%

/**********************************************************************************
 *                         Reduction rules - (and actions)
 *There are comments for the first few rules and all of the other are done the same way according 
 *to each reduction rule  
 ***********************************************************************************/

/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/
PROGRAM: TDEFS FDEFS MAIN_FUNCTION
{
	/*concatenate all children to a list*/
	/*Now, make the father node*/
	/*Update the global pointer for dumping the parse tree*/
	//vparseTree = $$.node;
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

TDEFS: TDEFS TK_defstruct '{' DECLARLIST '}' TK_id ';'
{
}
| /*epsilon*/
;

/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

FDEFS: FDEFS TYPE TK_id '(' FUNC_ARGLIST_FULL ')' BLK {}
| FDEFS TK_extern TYPE TK_id '(' FUNC_ARGLIST_FULL ')' ';' {
	/*concatenate all children to a list*/
	/*Now, make the father node*/
}
| /*epsilon*/{
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

FUNC_ARGLIST_FULL: FUNC_ARGLIST {
}
| /*epsilon*/{
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

FUNC_ARGLIST: FUNC_ARGLIST ',' DCL {
	/*concatenate all children to a list*/
	/*Now, make the father node*/

}
| DCL {
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

MAIN_FUNCTION: TK_main BLK {
}
| /*epsilon*/{
}
;

BLK: DECLARATIONS '{' LIST '}' {

}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

DECLARATIONS: TK_var DECLARLIST {

}
| /*epsilon*/{
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

DECLARLIST: DECLARLIST DCL ';' {

}

| DCL ';' {

}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

DCL: TK_id ':' TYPE {

}
| TK_id ':' TK_id {

}
| TK_id ',' DCL {
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

TYPE: TK_integer {
}
| TK_real {
}
;

LIST: LIST STMT {
}
| /*epsilon*/
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

STMT: ASSN
| CNTRL
| READ
| WRITE
| STMT_RETURN
| BLK
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

STMT_RETURN: TK_return '(' EXP ')' ';' {
}
;
/**********************************************************************************
 *                        WRITE
 ***********************************************************************************/

WRITE: TK_write '(' EXP ')' ';' {

	if ($3.type == INT) {
		buffer.emit("PRNTI I" + to_string($3.registerNum));
	}
	else if ($3.type == REAL) {
		buffer.emit("PRNTR R" + to_string($3.registerNum));
	} else {
		//(our internal error)
	}

}
| TK_write '(' TK_str ')' ';' {

	for (size_t i = 0; i < $3.value.length(); i++) {
		char currentChar = $3.value[i];
		//take care of \n and \r :
		if (currentChar == '\\' && $3.value[i+1] == 'n') {
				currentChar = '\n';
				i++;
		}else if (currentChar == '\\' && $3.value[i+1] == 't') {
				currentChar = '\t';
				i++;
		}
		//cast to asci
		int asci_char = static_cast<int>(currentChar);
		buffer.emit("PRNTC " + to_string(asci_char));
	}

}
;
/**********************************************************************************
 *                        READ
 ***********************************************************************************/

READ: TK_read '(' LVAL ')' ';' {
	
	//check for type semantics
	if($3.type != INT && $.type != REAL){
		//semantic error - read exept only INT or REAL
		cerr << "Semantic error:"
		<< " READ expecting types: REAL or INT "
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	
	//stage1 read into a temp register
	//compute string to emit
	string toEmitRead = ($3.type == INT) ? "READI I" : "READR R";
	int reg = $3.registerNum; // the register we read into
	toEmitRead+= to_string(reg);
	
	//now, do the job
	buffer.emit(toEmitRead);
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

ASSN: LVAL TK_assign EXP ';' {

}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

LVAL: TK_id {
	//todo: set type as INT or REAL (for READ to work)
}
| STREF {
	//todo: set type as something different from INT and REAL (for READ to work)
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

CNTRL: TK_if BEXP TK_then STMT TK_else STMT {

}
| TK_if BEXP TK_then STMT {

}
| TK_while BEXP TK_do STMT {
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

BEXP: BEXP TK_or BEXP {
}
| BEXP TK_and BEXP {
}
| TK_not BEXP {
}
| EXP TK_relop EXP {
}
| '(' BEXP ')' {
}
;
/**********************************************************************************
 *                        EXP
 ***********************************************************************************/

EXP: EXP TK_addop EXP {

	int leftRegister = $1.registerNum;
	int rightRegister = $3.registerNum;

	//check types
	if($1.type != $3.type) { //different types
		//erorr
		cerr << "Semantic error:"
		<< " different types, EXP  TK_addop EXP"
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	//set my type
	if($1.type == REAL) {
		$$.type = REAL;
	} else if($1.type = INT) {
		$$.type = INT;
	} else {
		//semantic error
		cerr << "Semantic error:"
		<< " EXP TK_addop EXP expecting types: REAL or INT "
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}

	//EMIT
	string myType;
	if ($$.type == REAL) {
		myType += "R";
	}
	else {
		myType += "I";
	}

	$$.registerNum = bank.getRegister($$.type);

	if ($2.value == "+") {
		buffer.emit("ADD2" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
		buffer.print();
	}
	else { // "-"
		buffer.emit("SUBT" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
		buffer.print();
	}
}
| EXP TK_mulop EXP {

	int leftRegister = $1.registerNum;
	int rightRegister = $3.registerNum;

	//check types
	if($1.type != $3.type) { //different types
		//erorr
		cerr << "Semantic error:"
		<< " different types, EXP*EXP"
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	//set my type
	if($1.type == REAL) {
		$$.type = REAL;
	} else if($1.type = INT) {
		$$.type = INT;
	} else {
		//semantic error
		cerr << "Semantic error:"
		<< " EXP TK_mulop EXP expecting types: REAL or INT "
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);

	}
	//EMIT

	string myType;
	if ($$.type == REAL) {
		myType += "R";
	}
	else {
		myType += "I";
	}

	$$.registerNum = bank.getRegister($$.type);

	if ($2.value == "*") {
		buffer.emit("MULT" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
		buffer.print();
	}
	else { // "/"
		buffer.emit("DIVD" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
		buffer.print();
	}

}
| '(' EXP ')' {

	$$ = $2;
}
| '(' TYPE ')' EXP {
	// Explicit casting: int to real and real to int. all other casting options are semantics errors.

	if($2.type == REAL) {

		if ($4.type == INT) {
			// TYPE the actual type is a string in .type field
			$$.type = $2.type;//REAL

			//get register
			$$.registerNum = bank.getRegister($$.type);

			//emit
			buffer.emit("CITOR R" + to_string($$.registerNum) + " I" + to_string($4.registerNum));
			buffer.print();
		} else {
			//semantic error
			cerr << "Semantic error:"
			<< " '(' TYPE ')' EXP expecting different types"
			<< " in line number " << to_string(yylineno) << endl;
			exit(EXIT_SEMANTIC_FAILURE);
		}

	} else if($2.type == INT) {

		if ($4.type == REAL) {
			// TYPE the actual type is a string in .type field
			$$.type = $2.type;//INT

			//get register
			$$.registerNum = bank.getRegister($$.type);

			// emit
			buffer.emit("CRTOI I" + to_string($$.registerNum) + " R" + to_string($4.registerNum));
			buffer.print();
		} else {
			//semantic error
			cerr << "Semantic error:"
			<< " '(' TYPE ')' EXP expecting different types"
			<< " in line number " << to_string(yylineno) << endl;
			exit(EXIT_SEMANTIC_FAILURE);
		}
	} else {

		//semantic error
		cerr << "Semantic error:"
		<< " '(' TYPE ')' EXP types should be INT or REAL"
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
}
| TK_id {
}
| STREF {

}
| TK_num {
	//deterine value
	if ($1.value.find('.') != $1.value.npos) {
		$$.type = REAL;
	}
	else {
		$$.type = INT;
	}
	//ger register
	$$.registerNum = bank.getRegister($$.type);

	//emit
	if ($$.type == REAL) { //real
		buffer.emit("COPYR R" + to_string($$.registerNum) + " " + $1.value);
		buffer.print();
	}
	else { //int
		buffer.emit("COPYI I" + to_string($$.registerNum) + " " + $1.value);
		buffer.print();
	}

}
| CALL {
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

STREF: TK_id '[' TK_id ']' {

}
| STREF '[' TK_id ']' {
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

CALL: TK_call TK_id '(' CALL_ARGS_FULL ')' {
}
;

CALL_ARGS_FULL: CALL_ARGS {
}
| /*epsilon*/{
}
;

CALL_ARGS: EXP {
}
| CALL_ARGS ',' EXP {
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

%%

// printig an error when no reduction rule can be applied.code 2 of error as requested showind the syntax error details
void yyerror(const char* msg)
{
	printf("Syntax error: '%s' in line number %d\n", yytext, yylineno);
	exit(EXIT_SYNTAX_FAILURE);
}

