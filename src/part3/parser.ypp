% {
	/* Project part 2 - Bison file */

	/**********************************************************************************
	 *                                   Includes
	 ***********************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include "common.hpp"
#include "parser.tab.hpp"

	using namespace std;

	ParserNode* parseTree;
	/**********************************************************************************
	 *                                   Header
	 ***********************************************************************************/
//We create the parser nodes for each token in the lexical analyser. 
//Using yylval common data structure we transfer the nodes to the parser unit. 
//In the parser we only create the father node, connect the nodes and build the tree.

	/**********************************************************************************
	 *                                   Function Declarations
	 ***********************************************************************************/
	extern int yylex();
	extern char* yytext;
	extern int yylineno;
	void yyerror(const char* msg);
	%}

/**********************************************************************************
 *                                   Tokens
 ***********************************************************************************/

%token TK_id
%token TK_real
%token TK_integer
%token TK_write
%token TK_read
%token TK_while
%token TK_do
%token TK_if
%token TK_then
%token TK_else
%token TK_main
%token TK_var
%token TK_call
%token TK_return
%token TK_defstruct
%token TK_extern
%token TK_num
%token TK_str
%token ':'
%token ';'
%token '{'
%token '}'
%token '('
%token ')'
%token ','
%token '['
%token ']'

/**********************************************************************************
 *                         Operators: Associativity 
 ***********************************************************************************/

%right TK_assign
%left TK_or
%left TK_and
%left TK_relop
%left TK_addop
%left TK_mulop
%right TK_not
%left '[' ']'
%left '{' '}'
%left '(' ')'
/**********************************************************************************
 *                         Operators: Precedence  
 ***********************************************************************************/

%precedence TK_then
%precedence TK_else

%%

/**********************************************************************************
 *                         Reduction rules - (and actions)
 *There are comments for the first few rules and all of the other are done the same way according 
 *to each reduction rule  
 ***********************************************************************************/

/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/
PROGRAM: TDEFS FDEFS MAIN_FUNCTION
{
	/*concatenate all children to a list*/
	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	/*Now, make the father node*/
	$$.node = makeNode("PROGRAM",NULL,$1.node);
	/*Update the global pointer for dumping the parse tree*/
	parseTree = $$.node;
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

TDEFS: TDEFS TK_defstruct '{' DECLARLIST '}' TK_id ';'
{
	/*concatenate all children to a list*/
	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$1.node = concatList($1.node,$4.node);
	$1.node = concatList($1.node,$5.node);
	$1.node = concatList($1.node,$6.node);
	$1.node = concatList($1.node,$7.node);
	/*Now, make the father node*/
	$$.node = makeNode("TDEFS",NULL,$1.node);

}
| /*epsilon*/{$$.node = makeNode("TDEFS",NULL, makeNode("EPSILON",NULL,NULL));}
;

/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

FDEFS: FDEFS TYPE TK_id '(' FUNC_ARGLIST_FULL ')' BLK {

	/*concatenate all children to a list*/
	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$1.node = concatList($1.node,$4.node);
	$1.node = concatList($1.node,$5.node);
	$1.node = concatList($1.node,$6.node);
	$1.node = concatList($1.node,$7.node);
	/*Now, make the father node*/
	$$.node = makeNode("FDEFS",NULL,$1.node);

}
| FDEFS TK_extern TYPE TK_id '(' FUNC_ARGLIST_FULL ')' ';' {
	/*concatenate all children to a list*/
	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$1.node = concatList($1.node,$4.node);
	$1.node = concatList($1.node,$5.node);
	$1.node = concatList($1.node,$6.node);
	$1.node = concatList($1.node,$7.node);
	$1.node = concatList($1.node,$8.node);
	/*Now, make the father node*/
	$$.node = makeNode("FDEFS",NULL,$1.node);
}
| /*epsilon*/{$$.node = makeNode("FDEFS",NULL, makeNode("EPSILON",NULL,NULL));}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

FUNC_ARGLIST_FULL: FUNC_ARGLIST {$$.node = makeNode("FUNC_ARGLIST_FULL",NULL, $1.node);}
| /*epsilon*/{$$.node = makeNode("FUNC_ARGLIST_FULL",NULL, makeNode("EPSILON",NULL,NULL));}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

FUNC_ARGLIST: FUNC_ARGLIST ',' DCL {
	/*concatenate all children to a list*/
	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	/*Now, make the father node*/
	$$.node = makeNode("FUNC_ARGLIST",NULL, $1.node);

}
| DCL {
	$$.node = makeNode("FUNC_ARGLIST",NULL, $1.node);
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

MAIN_FUNCTION: TK_main BLK {
	$1.node = concatList($1.node,$2.node);
	$$.node = makeNode("MAIN_FUNCTION",NULL,$1.node);
}
| /*epsilon*/{$$.node = makeNode("MAIN_FUNCTION",NULL, makeNode("EPSILON",NULL,NULL));}
;

BLK: DECLARATIONS '{' LIST '}' {

	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$1.node = concatList($1.node,$4.node);
	$$.node = makeNode("BLK",NULL,$1.node);
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

DECLARATIONS: TK_var DECLARLIST {

	$1.node = concatList($1.node,$2.node);
	$$.node = makeNode("DECLARATIONS",NULL,$1.node);

}
| /*epsilon*/{$$.node = makeNode("DECLARATIONS",NULL, makeNode("EPSILON",NULL,NULL));}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

DECLARLIST: DECLARLIST DCL ';' {

	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$$.node = makeNode("DECLARLIST",NULL,$1.node);
}

| DCL ';' {

	$1.node = concatList($1.node,$2.node);
	$$.node = makeNode("DECLARLIST",NULL,$1.node);
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

DCL: TK_id ':' TYPE {

	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$$.node = makeNode("DCL",NULL,$1.node);

}
| TK_id ':' TK_id {

	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$$.node = makeNode("DCL",NULL,$1.node);
}
| TK_id ',' DCL {
	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$$.node = makeNode("DCL",NULL,$1.node);
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

TYPE: TK_integer {$$.node = makeNode("TYPE",NULL, $1.node);}
| TK_real {$$.node = makeNode("TYPE",NULL, $1.node);}
;

LIST: LIST STMT {$1.node = concatList($1.node,$2.node);
	$$.node = makeNode("LIST",NULL, $1.node);}
| /*epsilon*/{$$.node = makeNode("LIST",NULL, makeNode("EPSILON",NULL,NULL));}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

STMT: ASSN {$$.node = makeNode("STMT",NULL, $1.node);}
| CNTRL {$$.node = makeNode("STMT",NULL, $1.node);}
| READ {$$.node = makeNode("STMT",NULL, $1.node);}
| WRITE {$$.node = makeNode("STMT",NULL, $1.node);}
| STMT_RETURN {$$.node = makeNode("STMT",NULL, $1.node);}
| BLK {$$.node = makeNode("STMT",NULL, $1.node);}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

STMT_RETURN: TK_return '(' EXP ')' ';' {
	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$1.node = concatList($1.node,$4.node);
	$1.node = concatList($1.node,$5.node);
	$$.node = makeNode("STMT_RETURN",NULL,$1.node);
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

WRITE: TK_write '(' EXP ')' ';' {

	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$1.node = concatList($1.node,$4.node);
	$1.node = concatList($1.node,$5.node);
	$$.node = makeNode("WRITE",NULL,$1.node);
}
| TK_write '(' TK_str ')' ';' {
	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$1.node = concatList($1.node,$4.node);
	$1.node = concatList($1.node,$5.node);
	$$.node = makeNode("WRITE",NULL,$1.node);
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

READ: TK_read '(' LVAL ')' ';' {

	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$1.node = concatList($1.node,$4.node);
	$1.node = concatList($1.node,$5.node);
	$$.node = makeNode("READ",NULL,$1.node);
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

ASSN: LVAL TK_assign EXP ';' {

	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$1.node = concatList($1.node,$4.node);
	$$.node = makeNode("ASSN",NULL,$1.node);

}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

LVAL: TK_id {$$.node = makeNode("LVAL",NULL, $1.node);}
| STREF {$$.node = makeNode("LVAL",NULL, $1.node);}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

CNTRL: TK_if BEXP TK_then STMT TK_else STMT {

	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$1.node = concatList($1.node,$4.node);
	$1.node = concatList($1.node,$5.node);
	$1.node = concatList($1.node,$6.node);
	$$.node = makeNode("CNTRL",NULL,$1.node);

}
| TK_if BEXP TK_then STMT {

	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$1.node = concatList($1.node,$4.node);
	$$.node = makeNode("CNTRL",NULL,$1.node);

}
| TK_while BEXP TK_do STMT {
	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$1.node = concatList($1.node,$4.node);
	$$.node = makeNode("CNTRL",NULL,$1.node);
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

BEXP: BEXP TK_or BEXP {
	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$$.node = makeNode("BEXP",NULL,$1.node);
}
| BEXP TK_and BEXP {
	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$$.node = makeNode("BEXP",NULL,$1.node);
}
| TK_not BEXP {
	$1.node = concatList($1.node,$2.node);
	$$.node = makeNode("BEXP",NULL,$1.node);
}
| EXP TK_relop EXP {
	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$$.node = makeNode("BEXP",NULL,$1.node);
}
| '(' BEXP ')' {
	$1.node = concatList($1.node,$2.node);
	$1.node = concatList($1.node,$3.node);
	$$.node = makeNode("BEXP",NULL,$1.node);
}
;
/**********************************************************************************
 *                        EXP
 ***********************************************************************************/

EXP: EXP TK_addop EXP {

	int leftRegister = $1.registerNum;
	int rightRegister = $3.registerNum;

	//check types
	if($1.type != $3.type) { //different types
		//erorr
		cerr << "Semantic error:"
		<< " differnt types, EXP  TK_addop EXP"
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	//set my type
	if($1.type == REAL) {
		$$.type = REAL;
	} else if($1.type = INT) {
		$$.type = INT;
	}else{
		//semantic error
		cerr << "Semantic error:"
		<< " EXP TK_addop EXP expecting types: REAL or INT "
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}

	//EMIT

	string myType = ($$.type == REAL) ? "R" : "I";

	$$.registerNum = bank.getRegister($$.type);

	if ($2.value == "+") {
		buffer.emit("ADD2" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
	}
	else { // "-"
		buffer.emit("SUBT" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
	}

	| EXP TK_mulop EXP {

		int leftRegister = $1.registerNum;
		int rightRegister = $3.registerNum;

		//check types
		if($1.type != $3.type) { //different types
			//erorr
			cerr << "Semantic error:"
			<< " differnt types, EXP*EXP"
			<< " in line number " << to_string(yylineno) << endl;
			exit(EXIT_SEMANTIC_FAILURE);
		}
		//set my type
		if($1.type == REAL) {
			$$.type = REAL;
		} else if($1.type = INT) {
			$$.type = INT;
		}else{
			//semantic error
			cerr << "Semantic error:"
			<< " EXP TK_mulop EXP expecting types: REAL or INT "
			<< " in line number " << to_string(yylineno) << endl;
			exit(EXIT_SEMANTIC_FAILURE);
		
		}
		//EMIT

		string myType = ($$.type == REAL) ? "R" : "I";

		$$.registerNum = bank.getRegister($$.type).;

		if ($2.value == "*") {
			buffer.emit("MULT" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
		}
		else { // "/"
			buffer.emit("DIVD" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
		}

	}
	| '(' EXP ')' {

		$$ = $2
	}
	| '(' TYPE ')' EXP {
		// Explicit casting: int to real and real to int. all other casting options are semantics errors.

		if($2.type == REAL) {

			if ($4.type == INT) {
				// TYPE the actual type is a string in .type field
				$$.type = $2.type; //REAL
				
				//get register
				$$.registerNum = bank.getRegister($$.type);
				
				//emit
				buffer.emit("CITOR R" + to_string($$.registerNum) + " I" + to_string($4.registerNum));
				
			} else {
				//semantic error
				cerr << "Semantic error:"
				<< " '(' TYPE ')' EXP expecting different types"
				<< " in line number " << to_string(yylineno) << endl;
				exit(EXIT_SEMANTIC_FAILURE);
			}

		} else if($2.type == INT) {

			if ($4.type == REAL) {
				// TYPE the actual type is a string in .type field
				$$.type = $2.type; //INT
				
				//get register
				$$.registerNum = bank.getRegister($$.type);
						
				// emit
				buffer.emit("CRTOI I" + to_string($$.registerNum) + " R" + to_string($4.registerNum));
				
							
			} else {
				//semantic error
				cerr << "Semantic error:"
				<< " '(' TYPE ')' EXP expecting different types"
				<< " in line number " << to_string(yylineno) << endl;
				exit(EXIT_SEMANTIC_FAILURE);
			}
		} else {

			//semantic error
			cerr << "Semantic error:"
			<< " '(' TYPE ')' EXP types should be INT or REAL"
			<< " in line number " << to_string(yylineno) << endl;
			exit(EXIT_SEMANTIC_FAILURE);
		}
	}
	| TK_id {
		$$.node = makeNode("EXP",NULL,$1.node);
	}
	| STREF {

	}
	| TK_num {
		//deterine value
		if ($1.value.find('.') != $1.value.npos) {
			$$.type = REAL;
		}
		else {
			$$.type = INT;
		}
		//ger register
		$$.registerNum = bank.getRegister($$.type);
		
		//emit
		if ($$.type == REAL) { //real
			buffer.emit("COPYR R" + to_string($$.registerNum) + " " + $1.value);
		}
		else { //int
			buffer.emit("COPYI I" + to_string($$.registerNum) + " " + $1.value);
		}
		
	}
	| CALL {
		$$.node = makeNode("EXP",NULL,$1.node);
	}
	;
	/**********************************************************************************
	 *                        PROGRAM
	 ***********************************************************************************/

	STREF: TK_id '[' TK_id ']' {
		$1.node = concatList($1.node,$2.node);
		$1.node = concatList($1.node,$3.node);
		$1.node = concatList($1.node,$4.node);
		$$.node = makeNode("STREF",NULL,$1.node);

	}
	| STREF '[' TK_id ']' {
		$1.node = concatList($1.node,$2.node);
		$1.node = concatList($1.node,$3.node);
		$1.node = concatList($1.node,$4.node);
		$$.node = makeNode("STREF",NULL,$1.node);
	}
	;
	/**********************************************************************************
	 *                        PROGRAM
	 ***********************************************************************************/

	CALL: TK_call TK_id '(' CALL_ARGS_FULL ')' {
		$1.node = concatList($1.node,$2.node);
		$1.node = concatList($1.node,$3.node);
		$1.node = concatList($1.node,$4.node);
		$1.node = concatList($1.node,$5.node);
		$$.node = makeNode("CALL",NULL,$1.node);
	}
	;

	CALL_ARGS_FULL: CALL_ARGS {
		$$.node = makeNode("CALL_ARGS_FULL",NULL, $1.node);
	}
	| /*epsilon*/{$$.node = makeNode("CALL_ARGS_FULL",NULL, makeNode("EPSILON",NULL,NULL));}
	;

	CALL_ARGS: EXP {$$.node = makeNode("CALL_ARGS",NULL, $1.node);}
	| CALL_ARGS ',' EXP {
		$1.node = concatList($1.node,$2.node);
		$1.node = concatList($1.node,$3.node);
		$$.node = makeNode("CALL_ARGS",NULL, $1.node);
	}
	;
	/**********************************************************************************
	 *                        PROGRAM
	 ***********************************************************************************/

	%%

// printig an error when no reduction rule can be applied.code 2 of error as requested showind the syntax error details
	void yyerror(const char* msg)
	{
		printf("Syntax error: '%s' in line number %d\n", yytext, yylineno);
		exit(EXIT_SYNTAX_FAILURE);
	}

