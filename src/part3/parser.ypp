%{
	/* Project part 3 - Bison file */

	/**********************************************************************************
	 *                                   Includes
	 ***********************************************************************************/
#include <stdlib.h>
#include <stdio.h>
#include "common.h"
#include "defintions.h"
#include "parser.tab.hpp"
using namespace std;
	/**********************************************************************************
	 *                                   Header
	 ***********************************************************************************/
//We create the parser nodes for each token in the lexical analyser. 
//Using yylval common data structure we transfer the nodes to the parser unit. 
//In the parser we only create the father node, connect the nodes and build the tree.
	/**********************************************************************************
	 *                                   Function Declarations
	 ***********************************************************************************/
	extern int yylex();
	extern char* yytext;
	extern int yylineno;
	void yyerror(const char* msg);
	%}

/**********************************************************************************
 *                                   Tokens
 ***********************************************************************************/

%token TK_id
%token TK_real
%token TK_integer
%token TK_write
%token TK_read
%token TK_while
%token TK_do
%token TK_if
%token TK_then
%token TK_else
%token TK_main
%token TK_var
%token TK_call
%token TK_return
%token TK_defstruct
%token TK_extern
%token TK_num
%token TK_str
%token ':'
%token ';'
%token '{'
%token '}'
%token '('
%token ')'
%token ','
%token '['
%token ']'

/**********************************************************************************
 *                         Operators: Associativity 
 ***********************************************************************************/

%right TK_assign
%left TK_or
%left TK_and
%left TK_relop
%left TK_addop
%left TK_mulop
%right TK_not
%left '[' ']'
%left '{' '}'
%left '(' ')'
/**********************************************************************************
 *                         Operators: Precedence  
 ***********************************************************************************/

%precedence TK_then
%precedence TK_else

%%

/**********************************************************************************
 *                         Reduction rules - (and actions)
 *There are comments for the first few rules and all of the other are done the same way according 
 *to each reduction rule  
 ***********************************************************************************/

/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/
PROGRAM: TDEFS FDEFS MAIN_FUNCTION
{
	/*concatenate all children to a list*/
	/*Now, make the father node*/
	/*Update the global pointer for dumping the parse tree*/
	//vparseTree = $$.node;
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

TDEFS: TDEFS TK_defstruct '{' DECLARLIST '}' TK_id ';'
{
}
| /*epsilon*/
;

/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

FDEFS: FDEFS TYPE TK_id '(' FUNC_ARGLIST_FULL ')' BLK {}
| FDEFS TK_extern TYPE TK_id '(' FUNC_ARGLIST_FULL ')' ';' {
	/*concatenate all children to a list*/
	/*Now, make the father node*/
}
| /*epsilon*/{
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

FUNC_ARGLIST_FULL: FUNC_ARGLIST {
}
| /*epsilon*/{
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

FUNC_ARGLIST: FUNC_ARGLIST ',' DCL {
	/*concatenate all children to a list*/
	/*Now, make the father node*/

}
| DCL {
	
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

MAIN_FUNCTION: TK_main BLK {
}
| /*epsilon*/{
}
;

BLK: DECLARATIONS '{' LIST '}' {

}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

DECLARATIONS: TK_var DECLARLIST {

}
| /*epsilon*/{
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

DECLARLIST: DECLARLIST DCL ';' {

}

| DCL ';' {

}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

DCL: TK_id ':' TYPE {
		
}
| TK_id ':' TK_id {

}
| TK_id ',' DCL {
}
;
/**********************************************************************************
 *                        TYPE
 ***********************************************************************************/

TYPE: TK_integer {
	
	$$.type = INT;
}
| TK_real {
	$$.type = REAL; 
}
;

LIST: LIST STMT {
}
| /*epsilon*/
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

STMT: ASSN
| CNTRL
| READ
| WRITE
| STMT_RETURN
| BLK
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

STMT_RETURN: TK_return '(' EXP ')' ';' {
}
;
/**********************************************************************************
 *                        WRITE
 ***********************************************************************************/

WRITE: TK_write '(' EXP ')' ';' {

	if ($3.type == INT) {
		buffer.emit("PRNTI I" + to_string($3.registerNum));
	}
	else if ($3.type == REAL) {
		buffer.emit("PRNTR R" + to_string($3.registerNum));
	} else {
		//(our internal error)
	}

}
| TK_write '(' TK_str ')' ';' {

	for (size_t i = 0; i < $3.value.length(); i++) {
		char currentChar = $3.value[i];
		//take care of \n and \r :
		if (currentChar == '\\' && $3.value[i+1] == 'n') {
				currentChar = '\n';
				i++;
		}else if (currentChar == '\\' && $3.value[i+1] == 't') {
				currentChar = '\t';
				i++;
		}
		//cast to asci
		int asci_char = static_cast<int>(currentChar);
		buffer.emit("PRNTC " + to_string(asci_char));
	}

}
;
/**********************************************************************************
 *                        READ
 ***********************************************************************************/

READ: TK_read '(' LVAL ')' ';' {
	
	//check for type semantics
		if($3.type != INT && $.type != REAL){
			//semantic error - read exept only INT or REAL
			cerr << "Semantic error:"
			<< " READ expecting types: REAL or INT "
			<< " in line number " << to_string(yylineno) << endl;
			exit(EXIT_SEMANTIC_FAILURE);
		}
		
		//stage1 read into a temp register
		//compute string to emit
		string toEmitRead = ($3.type == INT) ? "READI I" : "READR R";
		int reg = bank.getRegister($3.type); // the register we read into
		toEmitRead+= to_string(reg);
		//now, do the job
		buffer.emit(toEmitRead);
		
		//stage2: store to mem
		//compute string to emit
		string toEmitStore = ($3.type == INT) ? "STORI I" : "STORR R";
		toEmitStore+= to_string(reg);
		toEmitStore = toEmitStore + " " + to_string($3.adder) + " 0"; //the LVAL is in memmorry, addr stores where //FIXME:
		
		//now, do the job
		buffer.emit(toEmitStore);
}
;
/**********************************************************************************
 *                        ASSN
 ***********************************************************************************/

ASSN: LVAL TK_assign EXP ';' {

	//SEMANTIC CHECKS: assert both have the same types
	if($1.type != $3.type){
		cerr << "Semantic error:"
		<< " ASSN expecting same types "
		<< " in line number " << to_string(yylineno) << endl;
	}
	
	//set type
	$$.type = $1.type ;
	
	//case 1 : EXP is REAL or INT
	if($$.type == REAL || $$.type == INT){
		
		// assign value to lval memory.

		string toEmitStore = ($$.type == INT ) ? "STORI I" : "STORR R" ;
		buffer.emit(toEmitStore + to_string($3.registerNum) + " " + to_string($1.addr) + " 0");
	}
				
		
	//case 2: assignment between structs 
		
		//TODO:
		
}
;
/**********************************************************************************
 *                        LVAL
 ***********************************************************************************/

LVAL: TK_id {
	//(if type is INT or REAL, then READ will work)
	//SEMANTIC CHECKS:
	//is id in the sybol table?
	string name = $1.value;
	bool exists = symbolTable.find(name);
	if(!exists){
		cerr << "Semantic error: undeclared symbol '" << name << "' ";
		cerr << "in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	//lval can be a struct!
	
	//init LVL:
	$$.value = name;

	// set type of EXP :
	$$.type = symbolTable.getType(name);
	
	
	if($$.type != REAL && $$.type != INT){
		//todo:
		//means it is a struct, do we have to do something special?
	}
	
	//both cases
	$$.addr = symbolTable.getAddr(name);

	//anything else?	
}
| STREF {
	//todo: set type as something different from INT and REAL (for READ to work) ???
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

CNTRL: TK_if BEXP TK_then M STMT N TK_else M STMT {
	/* $1 if
	 * $2 B
	 * $3 then
	 * $4 M1
	 * $5 S1
	 * $6 N
	 * $7 else
	 * $8 M2
	 * $9 S2
	 */
	
	buffer.backpatch($2.trueList,  $4.quad);
	buffer.backpatch($2.falseList, $8.quad);
	// merge all three to S list
	std::set<int> tmp;
	MERGE(tmp, $5.nextList, $6.nextList);
	MERGE($$.nextList, tmp, $9.nextList);
}
| TK_if BEXP TK_then M STMT {
	
	

}
| TK_while BEXP TK_do STMT {
}
;
/**********************************************************************************
 *                        BEXP
 ***********************************************************************************/

BEXP: BEXP TK_or M BEXP {
	buffer.backpatch($1.falseList , $3.quad);
	MERGE($$.trueList, $1.trueList , $4.trueList);
	$$.falseList = $4.falseList;
}
| BEXP TK_and M BEXP {
	
	buffer.backpatch($1.trueList , $3.quad);
	$$.trueList = $4.trueList;
	MERGE($$.falseList, $1.falseList , $4.falseList);

}
| TK_not BEXP {
	$$.trueList = $2.falseList;
	$$.falseList = $2.trueList;
}
| EXP TK_relop EXP {
	//semantics checks
	//same type
	if($1.type != $3.type){
		//semantic error
		cerr << "Semantic error:"
		<< " EXP TK_relop EXP - types must be the same"
		<< " in line number " << to_string(yylineno) << endl;
	}
	//real of int only
	if($1.type != REAL && $1.type != INT){
		//semantic error
		cerr << "Semantic error:"
		<< " EXP TK_relop EXP expecting types: REAL or INT "
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	
	
	//allocate INT register for comparsion result
	$$.registerNum = bank.getRegister(INT);
	
	
	//the logic here is simple:
	//if ! (left relop right) branch <--------------- falseList
	//goto...                        <--------------- trueList

	//decide how to compare and branch
	string toEmitCompare;
	string toEmitBranch;

	if ($2.value == "==") {
		toEmitCompare  = "SEQU" ;
		toEmitBranch   = "BREQZ";
		
	}else if ($2.value == "<>"){
		toEmitCompare = "SNEQ"
		toEmitBranch   = "BREQZ";
		
	}else if ($2.value == "<"){
		toEmitCompare = "SLET";
		toEmitBranch = "BREQZ";
		
	}else if ($2.value == ">="){
		toEmitCompare = "SLET";
		toEmitBranch   = "BNEQZ";

		
	}else if ($2.value == ">"){
		toEmitCompare = "SGRT";
		toEmitBranch = "BREQZ";
		
	}else if ($2.value == "<="){
		toEmitCompare = "SGRT";
		toEmitBranch   = "BNEQZ";
	}
	
	//add type letter to toEmitCompare string
	string type_str = ($1.type == INT) ? "I" : "R" ;
	toEmitCompare+=type_str;
	
	//add the rest to compare_str
	toEmitCompare+=" I" + to_string($$.registerNum) + " " + type_str + to_string($1.registerNum) + " " + type_str + to_string($3.registerNum);
	
	//add the rest to branch_str , leave space to be later backpatched...
	toEmitBranch+=" I" + to_string($$.registerNum) + " ";
	
	
	//now, do the job!
	buffer.emit(toEmitCompare);
	$$.falseList.insert(buffer.nextQuad()); // falselist - branch
	buffer.emit(toEmitBranch);
	$$.trueList.insert(buffer.nextQuad()); //true list - goto
	buffer.emit("UJUMP ");
}
| '(' BEXP ')' {
	$$.trueList = $2.trueList;
	$$.falseList = $2.falseList;
}
;
/**********************************************************************************
 *                        EXP
 ***********************************************************************************/

EXP: EXP TK_addop EXP {

	int leftRegister = $1.registerNum;
	int rightRegister = $3.registerNum;

	//check types
	if($1.type != $3.type) { //different types
		//erorr
		cerr << "Semantic error:"
		<< " different types, EXP  TK_addop EXP"
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	//set my type
	if($1.type == REAL) {
		$$.type = REAL;
	} else if($1.type = INT) {
		$$.type = INT;
	} else {
		//semantic error
		cerr << "Semantic error:"
		<< " EXP TK_addop EXP expecting types: REAL or INT "
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}

	//EMIT
	string myType;
	if ($$.type == REAL) {
		myType += "R";
	}
	else {
		myType += "I";
	}

	$$.registerNum = bank.getRegister($$.type);

	if ($2.value == "+") {
		buffer.emit("ADD2" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
	}
	else { // "-"
		buffer.emit("SUBT" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
	}
}
| EXP TK_mulop EXP {

	int leftRegister = $1.registerNum;
	int rightRegister = $3.registerNum;

	//check types
	if($1.type != $3.type) { //different types
		//erorr
		cerr << "Semantic error:"
		<< " different types, EXP*EXP"
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	//set my type
	if($1.type == REAL) {
		$$.type = REAL;
	} else if($1.type = INT) {
		$$.type = INT;
	} else {
		//semantic error
		cerr << "Semantic error:"
		<< " EXP TK_mulop EXP expecting types: REAL or INT "
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);

	}
	//EMIT

	string myType;
	if ($$.type == REAL) {
		myType += "R";
	}
	else {
		myType += "I";
	}

	$$.registerNum = bank.getRegister($$.type);

	if ($2.value == "*") {
		buffer.emit("MULT" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
	}
	else { // "/"
		buffer.emit("DIVD" + myType + " " + myType + to_string($$.registerNum) + " " + myType + to_string(leftRegister) + " " + myType + to_string(rightRegister));
	}

}
| '(' EXP ')' {

	$$ = $2;
}
| '(' TYPE ')' EXP {
	// Explicit casting: int to real and real to int. (or casting from the same type. all other casting options are semantics errors.

	if( ($2.type != INT && $2.type != REAL) || ($4.type != INT && $4.type != REAL)){

		//semantic error
		cerr << "Semantic error:"
		<< " '(' TYPE ')' EXP types should be INT or REAL"
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
		
	}
	if($2.type == REAL) {
		$$.type = $2.type;//REAL

		if ($4.type == INT) {
			// TYPE the actual type is a string in .type field

			//get register
			$$.registerNum = bank.getRegister($$.type);

			//emit
			buffer.emit("CITOR R" + to_string($$.registerNum) + " I" + to_string($4.registerNum));

		} else { // both types are ints
			//nothing to do do ...
			
		}

	} else if($2.type == INT) {
		$$.type = $2.type;//INT

		if ($4.type == REAL) {
			// TYPE the actual type is a string in .type field

			//get register
			$$.registerNum = bank.getRegister($$.type);

			// emit
			buffer.emit("CRTOI I" + to_string($$.registerNum) + " R" + to_string($4.registerNum));

		} else { // both types are real
			//nothing to do do ...
		}
		
	} else { // already taken care of.. but nvm
		//semantic error
		cerr << "Semantic error:"
		<< " '(' TYPE ')' EXP types should be INT or REAL"
		<< " in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
}
| TK_id {
	
	// check if id is declared in the current scope:
	string name = $1.value;
	
	//semantics checks:
	bool exists = symbolTable.find(tmp);
	if (!exists) {
		cerr << "Semantic error: undeclared symbol '" << name << "' ";
		cerr << "in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
		
	// check if id is int or real:
	type_t myType = symbolTable.getType(name);
	if ( myType != INT && myType!= REAL) {
		cerr << "Semantic error: invalid use of symbol '" << name << "'";
		cerr << "in line number " << to_string(yylineno) << endl;
		exit(EXIT_SEMANTIC_FAILURE);
	}
	
	//init EXP:
	
	// set type of EXP :
	$$.type = myType;
	string toEmitLoad = ($$.type == INT) ? "LOADI I" : "LOADR R";
	
	// allocate a register for EXP :
	$$.registerNum = bank.getRegister($$.type);
	toEmitLoad+= to_string($$.registerNum);
	
	//get adder, in order to load
	int addr = symbolTable.getAddr(name);
	//TODO: should save the addr for EXP ? (I think we should not, so I avoid saving it to avoid errors).
	
	
	//load to register
	buffer.emit(toEmitLoad + " 0 " + to_string(addr)); //FIXME: check if the address is right
	
}
| STREF {
	
	//TODO:

}
| TK_num {
	//deterine value
	if ($1.value.find('.') != $1.value.npos) {
		$$.type = REAL;
	}
	else {
		$$.type = INT;
	}
	//ger register
	$$.registerNum = bank.getRegister($$.type);

	//emit
	if ($$.type == REAL) { //real
		buffer.emit("COPYR R" + to_string($$.registerNum) + " " + $1.value);
	}
	else { //int
		buffer.emit("COPYI I" + to_string($$.registerNum) + " " + $1.value);
	}

}
| CALL {
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

STREF: TK_id '[' TK_id ']' {

}
| STREF '[' TK_id ']' {
}
;
/**********************************************************************************
 *                        PROGRAM
 ***********************************************************************************/

CALL: TK_call TK_id '(' CALL_ARGS_FULL ')' {
}
;

CALL_ARGS_FULL: CALL_ARGS {
}
| /*epsilon*/{
}
;

CALL_ARGS: EXP {
}
| CALL_ARGS ',' EXP {
}
;
/**********************************************************************************
 *                        MARKERS :
 ***********************************************************************************/

M : /* epsilon */ 
{
	$$.quad = buffer.nextQuad();
}

N : /* epsilon */ 
{	
	// set the nextList
	$$.nextList.insert(buffer.nextQuad());
	
	// emit goto
	buffer.emit("UJUMP ");
}

%%

// printig an error when no reduction rule can be applied.code 2 of error as requested showind the syntax error details
void yyerror(const char* msg)
{
	printf("Syntax error: '%s' in line number %d\n", yytext, yylineno);
	exit(EXIT_SYNTAX_FAILURE);
}

